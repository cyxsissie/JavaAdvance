# 作业一
不同 GC 和堆内存的总结


## 串行 GC（Serial GC）

**XX:+UseSerialGC 配置串行 GC**

串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-
整理）算法。
两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。

可使用串行GC和堆内存的场景
* 1、如果应用的堆大小在100MB以内可以使用。
* 2、如果应用在一个单核单线程的服务器上面，并且对应用暂停的时间无需求。
  
## 并行GC（Parallel GC）
**XX:+UseParallelGC**

年轻代和老年代的垃圾回收都会触发 STW 事件。
在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweep-compact）算法。

**-XX：ParallelGCThreads=N** 来指定 GC 线程数， 其默认值为 CPU 核心数。

并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。
* 在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；
* 在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。

可使用并行GC和堆内存的场景
* 如果需要应用在高峰期有较好的性能，但是对应用停顿时间无高要求（比如：停顿1s甚至更长）。

## CMS GC

**XX:+UseConcMarkSweepGC**

其对年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep (  标记-清除)算法。
CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。

可使用并行GC和堆内存的场景
* cms 于 吞吐量相对于其他回收器明显存在劣势，回收时间不太稳定



## G1 GC
**XX:+UseG1GC**
G1 GC 将 STW 停顿的时间和分布，变成 可预期且可配置的。

可使用并行GC和堆内存的场景
* 内存越大的情况下 G1 回收的效率越高，gc时间比其他回收器时间短